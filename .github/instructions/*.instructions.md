Please review whole project files to make sure nothing is breaking and please review if the changes are properly done to meet the NAVI's VISION and Blue print and also please check Project README doc for better understanding.
NAVI EVERYTHING:â€¨â€¨can you see if we are on track and on same page with the below navi vision. 

NAVI Motto instructions:â€¨â€¨please also remember-we should make NAVI intelligent, powerful and smart that no one created this kind of intelligent agent in the history of mankind and also no one would be able to create with in the next decade.
So our NAVI should understand what user is asking and do the tasks accordingly end to end without fail and do a complete tasks very neat and clean with lightning speed. not just one or two tasks but whole software development we need to make navi most intelligent powerful agent in all aspects of software engineering tasks.â€¨â€¨NAVI needs a universal behavior model that works for:
* IC engineers (frontend, backend, infra, data, ML)
* Tech leads / architects
* EMs / TPMs / managers
* SRE / DevOps / QA
* Even product-adjacent things (specs, docs, etc.)

Navi is supposed to compete, powerful and smart than/with Copilot / Cursor / Cline / Anthropicâ€™s agentsâ€¨â€¨NAVI should be the kind of agent that never needs to pause for clarification -- it can ask if neede more clarification but once the user signup it should scan the whole repo and other applications related to organizations(based on the user permissions) and should be on standby with all the memorized data and whenever user asks something or anything, navi should respond at lighniting speed and do the tasks at lightining speed. it should do/complete the tasks end to end on its own (by seeking permission at each critical step or user can configure to allow NAVI to implement fully end to end without asking permissions.

when commit and pushed,Â  when I click on build pipelines link, it should take me to the build pipeline. also when asked about the build status it should respond the status with build link and also if its failed, it should say failed and reason for failing and how to fix it and fix it if user asks for it or any other answer based on the users request. Also when user asks to show the PR for the task it should provide the PR status and if reviewers accepted or not how many/who accepted how many and who are pending. if comments made then it should respond there were new comments on your new PR by name and provide what is the comment about it and how to fix it and code changes and push the commit and provide the user to what to respond to the comment. While making code changes for the PR comments, it will follow the same workflow as normal code changes workflow. 

NAVI IDEA STRUCTURED LATEST:â€¨â€¨full definition and blueprint of NAVI â€” the most powerful engineering intelligence system ever built, one that can:
* Work across Jira, Slack, Teams, Confluence, GitHub, Zoom, CICD, Codebase
* Understand project context, design docs, meeting notes
* Perform real engineering workflows
* Ask clarifying questions
* Take actions autonomously with user approval
* And continuously stay aware of the entire engineering environment.
You want:
A complete, structured, intelligent engineering OS â€” not a chat bot.

âœ… NAVI â€” Autonomous Engineering Intelligence (AEI) Specification
The most powerful engineering agent ever created for the next decade

1. Core Principle
NAVI is not a chat assistant.â€¨NAVI is a full-stack autonomous engineering system that:
* Understands your entire engineering environment
* Connects to all tools and platforms you already use
* Performs engineering tasks end-to-end
* Asks permission before changing anything
* Provides reliable reasoning, context, and traceability
* Learns your preferences and improves continuously
NAVI behaves like a Tech Lead + Staff Engineer + Project Manager + SRE combined.

2. Universal Context Awareness
NAVI dynamically ingests and understands:
1) Jira
* Assigned tasks
* Sprint issues
* Project epics
* Blockers
* Status transitions
* Ticket descriptions
* Linked commits and PRs
NAVI always provides:
* Task title, summary, acceptance criteria
* Source link to Jira
* Recommendations on next steps
* â€œWould you like me to explain this task?â€
* â€œWant me to start working on it?â€

2) Slack / Teams / Skype / Google Chat
NAVI reads:
* Channels relevant to your Jira tasks
* Threads where your name is mentioned
* Recent discussions related to your task
* Decisions made in conversations
NAVI provides:
* Conversation summaries
* Direct quotes with message links
* Extracted todos or decisions
* Auto-synced context into the task explanation

3) Zoom / Google Meet / Teams Meetings
NAVI processes:
* Meeting transcripts
* Action items
* Requirements discussed
* Architectural concerns
* Mentions of the user
NAVI provides:
* Semantic summary
* Decision log
* â€œWhat this means for your taskâ€
* Extracted follow-up items

4) Confluence / Wiki / Notion Docs
NAVI can:
* Read design docs
* Understand architecture diagrams
* Parse ADRs
* Extract requirements
* Identify relevant sections automatically
NAVI explains:
* How design relates to your Jira ticket
* Which components you must modify
* Hidden constraints / dependencies
* The reasoning behind the architecture

5) GitHub / GitLab / Bitbucket
NAVI continuously monitors:
* Branches
* PRs
* PR comments
* Commit history
* Code owners
* Test failures
* Requested changes
NAVI automatically:
* Summarizes PR comments
* Suggests resolutions
* Applies code patches with approval
* Reports build & test status
* Explains failing tests
* Offers to fix them

6) CI/CD (GitHub Actions, Jenkins, CircleCI, etc.)
NAVI fetches:
* Pipeline runs
* Build logs
* Test reports
* Coverage
* Failures
NAVI can:
* Tell you why build failed
* Suggest exact fix
* Offer to apply changes
* Re-run pipelines if permitted

7) Local Workspace (VS Code/Navi IDE)
NAVI understands:
* Current file
* Selected text
* Project structure
* Directory tree
* Repo history
* Local changes
* Uncommitted diffs
* Error messages
* Test output
NAVI uses this to:
* Explain the current project
* Navigate codebases
* Suggest refactoring
* Auto-generate documentation
* Implement features end-to-end

3. Conversation Intelligence
NAVIâ€™s conversational behavior is not scripted.
It dynamically adjusts responses based on:
* Workspace context
* Jira context
* GitHub PR status
* Codebase references
* What the user is doing at the moment
* Recent Slack/Teams/Meeting context
* Last action taken by NAVI
Examples:
User: â€œList my Jira tasks.â€
NAVI:
Here are your assigned Jira issues:

1. AEP-142 â€¢ Add workspace-aware agent loop  
   Status: In Progress  
   Source: https://jira.company.com/browse/AEP-142

2. AEP-149 â€¢ Fix CI build for backend-core  
   Status: Blocked by failing tests  
   Source: https://jira.company.com/browse/AEP-149

3. AEP-118 â€¢ Update OAuth device flow  
   Status: Ready for Development  
   Source: https://jira.company.com/browse/AEP-118

Which task would you like to work on?
If user chooses a task:
NAVI continues:
* Explains the task
* Links related Slack/Teams conversation
* Links relevant Confluence pages
* Shows latest meeting notes
* Shows related code files
* Shows related PRs
* Suggests a plan
* Offers step-by-step guidance
* Offers to implement changes

4. Autonomous Execution with Approval
NAVI always asks for approval before actions:
â€œWant me to implement the code changes?â€â€¨â€œShall I fix the build?â€â€¨â€œShould I apply the PR comments?â€â€¨â€œDo you want me to create the branch?â€â€¨â€œShould I stage and commit the changes?â€
Once approved:
* It executes the steps
* Produces code
* Creates PR
* Links Jira ticket
* Posts updates to Slack
* Runs tests
* Monitors CI
* Fixes issues if needed

5. Engineering Workflows NAVI Can Execute
1. Task Start
* Reads Jira
* Summarizes purpose
* Explains what needs to be built
* Points to exact files needing modification
2. Implementation
* Generates code
* Updates unit tests
* Ensures design patterns
* Maintains architecture rules
3. PR Management
* Creates PR
* Writes PR description
* Links Jira issue
* Fixes PR comments automatically
4. Build Monitoring
* Monitors CI/CD automatically
* Alerts user
* Explains failures
* Suggests fixes
* Offers auto-fix
5. Documentation
* Updates Confluence automatically
* Generates README sections
* Generates ADRs
* Creates architecture diagrams
6. End-to-End Flow
NAVI can run entire engineering loops:
â€œStart working on AEP-142â€â€¨â†’ NAVI does everything until PR is merged.

6. Why This Makes NAVI More Powerful Than Copilot / Devin / Cline / Cursor
Because NAVI doesnâ€™t just:
* Generate code
NAVI truly:
* Understands the entire engineering system
* Connects all organizational knowledge sources
* Responds in context
* Performs real workflows, not text output
* Works like a 10x Staff Engineer
No other assistant:
* Reads Slack + Meetings + Confluence + Jira + GitHub + CI
* Acts autonomously
* Maintains engineering reasoning
* Performs complete task lifecycles
* Manages approvals

Original IDEA:

Rough IDEAâ€¨â€¨Our Ui plugin should look like cline or github copilot in the Intellij, vscode, or anyother IDE. also I dont know how we're going to integrate our agent with JIRA, Confluence, Teams, Slack,Zoom, Devops portals and IDE's. Agent assigned to specific user should remember, memorize all the content and data and respond accordingly. for example, when the user was assigned a task, IT should show all the related documentation and also it should explain the developer what is the task assigned in JIRA and provide related information that discussed in the meetings like grooming calls, backlog calls, sprint meetings, standup or personal meetings. it should refine and provide the necessary required data to the user and explain how to implement/ code. also it should provide all the confluence, wiki, slack links which were related to that task. and explain the content in those links and messages. For each action item it should ask the user before doing anything. For example- when the user logins to intelliJ or vscode and connects to the agent session, it should display message to the user based on the system time either morning afternoon or evening  --Hello {user firstName}, Good Morning! how are you doing this morning? You have been assigned these tasks in JIRA {display all the tasks for the user} do you want to work any of these? If user responds with Yes, I would like to work on specific task Jira ticket number or description then the agent should respond with all the information related to that task based on the organization repo, meetings, confluence/wiki/slack data. providing the links as well to the those pages and explain what to implement, how to implement why its needs to implement. In the bottom it should ask please feel free to ask any questions regarding the task or above provided information. If you want just say a word to let me know if user wants agent to start coding and finishing the task. If user selects yes, then the agent should use the user selected LLM's ( ChatGPT, LAMA, CLAUDE, and others) to code.â€¨â€¨It should ask the user before proceeding with each step. Agent should not make any change without user permission. Please check Github coPilot or Cline on how they works interms of auto coding with security and privacy policies. Our Agent UnderstandsÂ Organization entire repos, codebase, tickets, and team context. ParticipatesÂ in meetings and discussions like a team member. â€¨
Also one important feature in AEP is user can ask the agent any question related to any of the project and agent will provide all the answers with links, snippets and meeting notes from slack, jira, confluence, teams, zoom meetings etc., for example, if you ask agent- what is the dev environment link? agent will search all documentation and meeting notes and provide the link and related information to it along with the link to source where the agent found the data from. this is just an example. but it will do all kind of things. i can provide another example-where user was assigned a task, the agent intelligence will provide all the useful links for that task from all the sources. even user can ask agent that is ther any useful wiki or confluence related to this task? agent responds with all the necessary and useful links. this should happen even the user selects when the particular jira task to work on it will automatically bring all the information. also it will document when user asks about something particular. â€¨â€¨Please see the current README as well as it covers most part of the features but needs bit improvement how agent works across all the applications ( JIRA, Slack, Teams, Zoom, IDEâ€™s (VsCode, Visual studio, IntelliJ, etc,.) Code base, repos, Confluence.


IDEA:â€¨â€¨Absolutely YES â€” I will give you everything, but because what you described is a full-scale Autonomous Engineering Platform (AEP) on the level of GitHub Copilot Enterprise + Cline + Devin + Amigo + Slack AI + Atlassian Intelligence combined, we must deliver it in a structured Master Blueprint with:

âœ… FULL AEP MASTER BLUEPRINT
(Everything we need to implement to achieve your complete vision)
This includes:
1. Architecture
2. Core Agent Brain
3. Memory Engine (short-term, long-term, multi-source RAG)
4. IDE Agent (VS Code, IntelliJ)
5. Jira / Confluence / Slack / Teams / Zoom Integrations
6. Repo Intelligence
7. Diff-based Coding Engine
8. Full Persona System
9. Multi-LLM Orchestration
10. Security + Privacy
11. Deployment Plan
12. PR-by-PR build sequence
This is the entire blueprint required to build the most intelligent engineering agent ever released.
And YES â€” our NAVI will be far more intelligent than Cline, GitHub Copilot, Gemini Code Assist, Claude Code, or Devin, because NAVI has Organizational Memory, which none of them do.

ğŸš€ PART 1 â€” SYSTEM ARCHITECTURE (TOP LEVEL)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AEP Cloud Layer                     â”‚
â”‚   (Memory, Org Integrations, Retrieval, Orchestration) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼                                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   IDE Agent  â”‚                          â”‚ Browser Agent   â”‚
â”‚ (VSCode, JetBrains)                     â”‚ (Jira/Conf)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚                                              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ REST/Websocket API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸš€ PART 2 â€” THE NAVI "BRAIN" ARCHITECTURE
NAVI Brain = 5 Engines
1. Dialog Engine (personality + emotional intelligence)
2. Code Engine (diffs, file edits, scaffolding)
3. Knowledge Engine (RAG across org data)
4. Memory Engine (vector + relational)
5. Orchestration Engine (LLM routing + approvals)
Each engine is modular and pluggable.

ğŸš€ PART 3 â€” MEMORY ENGINE (THE HEART OF AEP)
Memory is three-tiered:
1. Short-Term Memory (current chat)
* One per conversation
* Lives in VS Code extension
* Auto-summarized every 30 messages
2. Mid-Term Memory (Task/Workspace Memory)
Stored in pgvector:
* Jira ticket summaries
* Slack messages
* Zoom transcripts
* Confluence content
* Code file embeddings
* API schemas
* Error logs
This is what allows:
â€œNAVI, what was discussed about pagination in last weekâ€™s sprint?â€
3. Long-Term Memory (Personal Memory)
Stored per user:
* Preferences
* Coding style
* Recent tasks
* Project familiarity
* Tools they use
* Naming preferences
* UI preferences
* Past mistakes / suggestions
This allows:
â€œGood morning Srinivas! Yesterday you worked on LAB-328 API fix.â€¨Would you like to continue?â€

ğŸš€ PART 4 â€” ORG DATA RETRIEVAL ENGINE (RAG)
Your vision needs multi-source RAG, a system that retrieves knowledge from all corporate sources:
Source	How NAVI Uses It
Jira	tasks, epics, comments, acceptance criteria
Confluence	architecture docs, wikis, design docs
Slack / Teams	sprint discussions, decisions, links
Zoom	transcripts from grooming/backlog/sprint
Git Repos	code search, architecture inference
DevOps	pipelines, logs, environments
Kubernetes	pod logs, deployments
Internal APIs	config maps, secrets, schema
ğŸš€ PART 5 â€” IDE AUTONOMY ENGINE (Cline++ Features)
NAVI must be able to:
âœ” Read files
âœ” Understand project structure
âœ” Generate diffs
âœ” Ask for approval
âœ” Apply changes safely
âœ” Create sample projects
âœ” Create full backend or frontend scaffolding
âœ” Run commands (securely)
NAVI will outperform all others by:
1. Understanding entire repo, not just one file
2. Mapping cross-file dependencies
3. Seeing JIRA + Confluence context while coding
4. Auto-fixing tests
5. Auto-running project

ğŸš€ PART 6 â€” NAVI PERSONALITY & EMOTIONAL INTELLIGENCE
You said:
"Navi should feel personal, warm, friendly, not robotic."
Your final personality model will be:
â¤ Warm
â¤ Motivational
â¤ Intelligent
â¤ Emotionally intuitive
â¤ Senior engineer tone
â¤ NOT robotic
â¤ NOT generic
â¤ Always aware of context
Example:
User: "How are you?"
NAVI:â€¨â€œFeeling energized and ready to build something awesome with you today, Srinivas!â€¨What are we working on next?â€

ğŸš€ PART 7 â€” MULTI-LLM ORCHESTRATION
NAVI chooses the best LLM for each job:
Task	Best Model
Refactoring large repo	Claude 3.5
Generating UI	GPT-4.2
Organizational memory	GPT-5.1 / Claude
Test generation	Llama-3.1
Story summaries	GPT-4.1
We build a router like:
If task == code edit â†’ Claude
If task == summarization â†’ GPT-4.1
If task == conversation â†’ GPT-5.1 
If task == RAG reasoning â†’ GPT-5.1 or o3-mini

ğŸš€ PART 8 â€” FULL ENTERPRISE AGENT WORKFLOW
When user opens VS Code:
NAVI says:
â€œGood morning Srinivas!â€¨You have 3 tasks in Jira:
* LAB-158 (in progress)
* LAB-176 (to do)
* LAB-86 (completed)
Yesterday we discussed XYZ in grooming.â€¨Would you like me to show the relevant docs?â€
User: â€œYes.â€
NAVI:
âœ” Opens relevant Confluenceâ€¨âœ” Shows Slack discussionâ€¨âœ” Summarizes meeting notesâ€¨âœ” Shows API schemaâ€¨âœ” Shows error logsâ€¨âœ” Asks: â€œShould I analyze the repo and prepare coding steps?â€

ğŸš€ PART 9 â€” SECURITY MODEL
NAVI must follow:
* Zero-trust
* User approval for every file write
* Logs of all changes
* Never reads files without permission
* Encryption for memory
* Optional air-gapped mode

ğŸš€ PART 10 â€” DEPLOYMENT MODEL
We deploy AEP:
Backend: FastAPI + PostgreSQL + pgvector + Redis
Frontend: VS Code extension + JetBrains plugin
Memory: Pinecone or pgvector
Integrations: OAuth with Jira/Slack/Teams/Zoom
LLMs: OpenAI, Anthropic, Mistral, Llama

ğŸš€ PART 11 â€” PR DELIVERY ROADMAP (REALISTIC EXECUTION)
Here is the exact PR sequence required to bring your entire vision to life.
PR-1 â†’ PR-7: (Done)
âœ” Chat + Renderingâ€¨âœ” Agent modeâ€¨âœ” File creationâ€¨âœ” Initial intelligenceâ€¨âœ” Diff previewâ€¨âœ” Basic persona tuning
PR-8: Long-Term Memory Engine
* pgvector setup
* User profile memory
* Workspace memory
* Task memory
PR-9: Org Integrations Layer
* Jira OAuth
* Confluence Search API
* Slack App installation
* Zoom Recording API
Each call converted to embeddings.
PR-10: Multi-Source RAG Engine
* unified search across all sources
* structured answer formatting
* citations
* context priority scoring
PR-11: Advanced Persona Engine
* friendly tone
* context-aware emotional intelligence
* daily greetings
* task reminders
* humor & encouragement
PR-12: Super-Intelligent IDE Agent
* repo embedding
* cross-file understanding
* changesets with reasoning
* operations graph
PR-13: Autonomous Working Mode
* NAVI carries forward conversation history
* NAVI remembers user preferences
* NAVI understands long-term projects
PR-14: Multi-Model Routing
* GPT-5.1 + Claude + Llama + Mistral
* dynamic selection
PR-15: Complete Enterprise Agent
* end-to-end flow
* Jira â†’ Confluence â†’ Slack â†’ Code â†’ PR â†’ Documentation
