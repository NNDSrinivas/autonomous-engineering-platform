from typing import List, Dict, Any, Optional
from pydantic import BaseModel
from datetime import datetime
import json


class PlanStep(BaseModel):
    """
    Represents a single step in the execution plan generated by the Planner Agent
    """

    id: str
    action_type: str  # "modify_file", "refactor", "search_code", "apply_patch", "run_command", "review", "ask_clarification"
    file_targets: List[str]
    description: str
    required_context: List[str]
    depends_on: List[str]
    priority: int = 1  # 1 = high, 2 = medium, 3 = low
    estimated_duration: int = 60  # seconds
    metadata: Dict[str, Any] = {}

    @classmethod
    def parse_steps(cls, llm_response: str) -> List["PlanStep"]:
        """
        Parse LLM response into structured plan steps
        """
        try:
            steps_data = json.loads(llm_response)
            return [cls(**step) for step in steps_data]
        except (json.JSONDecodeError, ValueError):
            # Fallback parsing for malformed JSON
            return cls._fallback_parse(llm_response)

    @classmethod
    def _fallback_parse(cls, text: str) -> List["PlanStep"]:
        """
        Fallback parser for when LLM doesn't return valid JSON
        """
        steps = []
        lines = text.split("\n")
        current_step = {}
        step_counter = 0

        for line in lines:
            line = line.strip()
            if line.startswith("- ") or line.startswith("â€¢ "):
                # New step detected
                if current_step:
                    steps.append(cls._create_fallback_step(current_step, step_counter))
                    step_counter += 1

                current_step = {"description": line[2:]}
            elif ":" in line and current_step:
                key, value = line.split(":", 1)
                current_step[key.strip().lower().replace(" ", "_")] = value.strip()

        # Add last step
        if current_step:
            steps.append(cls._create_fallback_step(current_step, step_counter))

        return steps

    @classmethod
    def _create_fallback_step(cls, step_data: Dict, counter: int) -> "PlanStep":
        """
        Create PlanStep from fallback parsed data
        """
        return cls(
            id=f"step_{counter}",
            action_type=step_data.get("action_type", "modify_file"),
            file_targets=(
                step_data.get("file_targets", "").split(",")
                if step_data.get("file_targets")
                else []
            ),
            description=step_data.get("description", ""),
            required_context=(
                step_data.get("required_context", "").split(",")
                if step_data.get("required_context")
                else []
            ),
            depends_on=(
                step_data.get("depends_on", "").split(",")
                if step_data.get("depends_on")
                else []
            ),
            priority=int(step_data.get("priority", 1)),
            estimated_duration=int(step_data.get("estimated_duration", 60)),
        )


class ExecutionResult(BaseModel):
    """
    Result from executing a plan step
    """

    step_id: str
    success: bool
    output: str
    error: Optional[str] = None
    files_modified: List[str] = []
    execution_time: float = 0.0
    metadata: Dict[str, Any] = {}

    @property
    def ok(self) -> bool:
        """Phase 4.1.2 compatibility property"""
        return self.success


class Plan(BaseModel):
    """
    Complete execution plan with metadata
    """

    id: str
    user_instruction: str
    steps: List[PlanStep]
    created_at: datetime
    estimated_total_time: int
    complexity_score: float
    repo_context: Dict[str, Any] = {}

    def get_executable_steps(self) -> List[PlanStep]:
        """
        Get steps that can be executed immediately (no pending dependencies)
        """
        executed_step_ids = {
            step.id for step in self.steps if getattr(step, "executed", False)
        }

        executable = []
        for step in self.steps:
            if getattr(step, "executed", False):
                continue

            # Check if all dependencies are satisfied
            deps_satisfied = all(
                dep_id in executed_step_ids for dep_id in step.depends_on
            )
            if deps_satisfied:
                executable.append(step)

        return executable

    def mark_step_executed(self, step_id: str):
        """
        Mark a step as executed
        """
        for step in self.steps:
            if step.id == step_id:
                setattr(step, "executed", True)
                break

    def get_progress(self) -> float:
        """
        Get execution progress as percentage
        """
        executed_count = sum(
            1 for step in self.steps if getattr(step, "executed", False)
        )
        return (executed_count / len(self.steps)) * 100 if self.steps else 0


class MemoryEvent(BaseModel):
    """
    Event stored in memory system
    """

    id: str
    user_id: str
    event_type: (
        str  # "instruction", "execution_result", "error", "feedback", "context_update"
    )
    content: Dict[str, Any]
    timestamp: datetime
    importance: float = 0.5  # 0.0 = low importance, 1.0 = critical
    tags: List[str] = []


class RepoMap(BaseModel):
    """
    Comprehensive repository analysis
    """

    root_path: str
    total_files: int
    languages: Dict[str, int]  # language -> file count
    dependencies: Dict[str, List[str]]  # file -> list of dependencies
    hotspots: List[str]  # files with high complexity/change frequency
    architecture: Dict[str, Any]  # project structure analysis
    complexity_metrics: Dict[str, float]
    last_updated: datetime


class AgentContext(BaseModel):
    """
    Context shared between agents
    """

    user_id: str
    workspace_root: str
    current_instruction: str
    repo_map: Optional[RepoMap] = None
    memory_context: List[MemoryEvent] = []
    execution_history: List[ExecutionResult] = []
    user_preferences: Dict[str, Any] = {}
    session_metadata: Dict[str, Any] = {}
